GSoC 2019: Project IRISpy 2.2
=============================

.. post:: July 21, 2019
   :author: Kris Stern
   :tags: GSoC, IRISpy
   :category: Google Summer of Code

To follow up, the problem encountered as reported in edition 2.1 in this series has been resolved with the help of my very helpful and responsive mentors. But some lingering issues remain, which we suspect to be mostly indexing-related, as is apparent from the way the given IDL code is translated into Python. So now all four versions of IRIS response can be used to produce some get_iris_response function output. However, say for example version=4, I have been only able to successfully reproduce 3/4's of the expected output as generated by the IDL version of the code. This is encouraging, as previously only half was the same as the target output. So the part of the IDL code that I am having some problems with is the following::

   ; 4. SJI effective areas
   if fix(r.version) le 3 then begin
    sz = size(r.coeffs_sji)
    for j=0,sz[3]-1 do begin
     ; calculate pre-launch area from the individual elements
     pl_a = r.geom_area
     for k=0,n_elements(r.index_el_sji[*,j])-1 do $
         pl_a=pl_a*r.elements[r.index_el_sji[k,j]].trans
     ; time dependent response
     rr = fit_iris_xput(tt,r.c_s_time[*,*,j],r.coeffs_sji[*,*,j])
     ; time dependent profiles
     for k=0L,ntt-1 do o[k].area_sji[*,j]=pl_a*rr[k]
    endfor
   endif else begin

    for nuv=0,1 do begin
      ; calculate baseline SJI area curves
      asji = r.geom_area
      for k=0,n_elements(r.index_el_sji[*,nuv*2])-1 do $
        asji=asji*r.elements[reform(r.index_el_sji[k,nuv*2:nuv*2+1])].trans

      ; apply time dependent profile shape adjustment to FUV SJI
      if ~nuv then begin
        ; FUV: apply FUV SG "slant", then normalize so that a weighted (2.4:1)
        ;      sum at C II and Si IV gives constant response
        wei = [2.4,1.0]   ; typical solar ratio CII : SiIV
        wav = r.c_f_lambda
        nwv = n_elements(wav)
        wav = [wav[0],(wav[nwv-2]*2.0+wav[nwv-1])/3.0]       ; 2 wvlngts in nm
        ; calculate baseline SG area for scaling purposes
        asg = r.geom_area
        for k=0,n_elements(r.index_el_sg[*,nuv])-1 do $
          asg=asg*r.elements[r.index_el_sg[k,nuv]].trans
        ; SG and SJI areas at wav
        asg2 = interpol(asg,r.lambda,wav)
        asj2 = fltarr(2,2)
        for j=0,1 do asj2[*,j]=interpol(asji[*,j],r.lambda,wav)
        ; calculate the normalized slant function scal, apply to asji
        for k=0L,ntt-1 do begin
          ; best-estimate slant, i.e., eff.area @ wav / baseline SG @ wav
          sca2 = interpol(o[k].area_sg[*,0],o[k].lambda,wav) / asg2
          ; normalize slant so that total(wei*asj2*sca2)/total(wei*asj2)=1
          for j=0,1 do begin
            sca2n = sca2 * total(wei*asj2[*,j])/total(wei*asj2[*,j]*sca2)
            scaln = interpol(sca2n,wav,r.lambda) > 0.0
            o[k].area_sji[*,j] = asji[*,j]*scaln
          endfor
        endfor
      endif else begin
        ; NUV: essentially same calculation as r.version=3
        for k=0L,ntt-1 do o[k].area_sji[*,2:3]=asji
      endelse
    endfor
    for j=0,3 do begin
    ; SJI specific time dependency
      rr = fit_iris_xput(tt,r.c_s_time[*,*,j],r.coeffs_sji[*,*,j])
      for k=0L,ntt-1 do o[k].area_sji[*,j]=o[k].area_sji[*,j]*rr[k]
    endfor
   endelse

   if keyword_set(angstrom) then o.lambda=o.lambda*10.
   return, o

This is the last but most complicated part of the get_iris_response code to compute the SJI effective areas for both the FUV's and NUV's. Something of interest to note is that the indexing in Python is the exact reverse of that in IDL. But it will be a lot fun trying to make the current code I have been working on to agree with the above 100%. I have been thinking maybe there is something regarding the IDL interpol function (for interpolation) that I have been translating wrong, as there is no exact equivalents in Python, and the closest thing to it is some two-part scipy.interpolate methods which I can use for the same task. Hopefully I will be able to overcome this almost last hurdle soon, say within a week or two. That would leave me with enough time to complete the project comfortably before the conclusion of GSoC 2019.
